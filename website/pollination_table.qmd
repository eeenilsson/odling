---
title: "Pollinationsschema"
execute:
  echo: false
---

Schemat tar hänsyn till genetisk kompatibilitet och närhet i blomningstid. Motsvarande information finns också i sökbara tabeller längre ner. 

Sammanfattningsvis kan sägas att de flesta sorter är åtminstone delvis genetiskt kompatibla och att det räcker för befruktning. Likaså överlappar blomningstiderna tillräckligt för de flesta sorter under de flesta år för att viss pollination skall kunna ske. I första hand kan man därför se till att undvika helt inkompatibla sorter och de som blommar i varsin ände av blomningsperioden. Vill man optimera chanserna för god pollination varje år kan det vara värt att välja sorter som blommar så nära varandra som möjligt i tid och har full genetisk kompatibilitet.

::: {.column-screen}
![](../../dropbox/images/plants/plot_pollination_table.png)
:::

# Instruktioner

För att kunna befruktas behöver sötkörsbär pollineras av ett körsbär av **annan sort** som 1) blommar samtidigt och 2) är genetiskt kompatibel. Undantaget är de _självfertila_ sorterna, vilka kan befrukta sig själva. Kvaliteten och storleken på skörden blir dock bättre om de pollineras av andra.

Efter namnet på körsbärssorten (på y-axeln, till vänster) anges inom klamrar vilken "haplotyp" sorten har. Den avgör vilka sorter som kan pollinera varandra (de som har samma haplotyper kan det inte). Hur den genetiska kompatibiliteten fungerar förklaras mer i detalj på sidan om [pollination](pollination_about.qmd).

Blomningstiden varierar i start och längd från år till år beroende på väderlek och klimat, men man brukar dela in den relativa blomningstiden för olika körsbärssorter i fem grupper från tidig till sen. Uppgifter om blomningstid varierar beroende på källa och för många sorter saknas information från svenska förhållanden. Blomningstiden i schemat ovan är en sammanvägning av den relativa blomningstiden från olika svenska och internationella källor. Den totala blomningstiden för alla sorter från tidig till sen varerar mellan 13 och 38 dagar beroende på år. Du kan läsa mer om blomning på sidan om [blomning](blooming.qmd).

Eftersom det finns en osäkerhet i uppgifterna om blomningstid bör pollinationsschemat bara användas som en fingervisning om vilka sorter som blommar ungefär samtidigt. Uppgifterna om genetisk kompatibilitet är troligen mer säkra och icke-kompatibla sorter bör undvikas. Dock är det inte givet att det genetiska material som använts för bestämning av S-haplotyp alltid överensstämmer med den sort som säljs under ett visst namn (Se Nybom 2012).

För sorterna 'Sam' och 'Hedelfinger' (som tycks blomma medelsent) rekommenderas från försäljarna flera sorter som är i tidig/medeltidig blomningsgrupp. Detta kan tala för att uppgifterna om blomningstid är osäkra, eller att dessa två sorter är feletiketterade.

Blomningstidens start och längd varierar från år till år. I medeltal överlappar blomningstiden i viss utsträckning för i stort sett alla sorter, men vissa år kan det vara för litet överlapp mellan vissa sorter för att korspollination skall kunna ske. Detta gäller framför allt de vars blomningstid ligger i varsin ände av blomningsperioden.

## Hur schemat avläses

Välj den sort du är intresserad av och leta upp namnet under "mottagare" (till vänster i schemat). Följ raden tills du kommer till grönfärgade cirklar. Cirkelns färg motsvarar närhet i blomningstid och cirkelns storlek motsvarar den genetiska kompatibiliteten med "pollinatören" vars namn avläses nedtill i schemat. En **grön** cirkel betyder att pollinatören blommar ungefär samtidigt. En **blå** cirkel att starten av blomningstiderna ligger en bit från varandra och risken finns att de inte överlappar tillräckligt vissa år. En **röd** cirkel betyder att blomningstiden är i varsin ände av spektrumet från tidig till sen blomning. Finns en cirkel av någon färg föreligger genetisk kompatibilitet mellan sorterna. Saknas genetisk kompatibilitet finns ingen cirkel alls. En svart ring runt cirkeln betyder att sorten angetts som pollinatör på någon svensk hemsida (Sveriges trädgårdsmästare, Plantagen, Wexthuset, Rangedala, eller Splendor).

Det finns skillnader mellan källor i vilka pollinatörer som anges för en viss sort och en del felaktigheter tycks finnas. Tex anges 'Fryksås' och 'Gårdebo' vara självfertila enligt Sveriges trädgårdsmästare, och Plantagen anger att 'Regina' kan pollineras av 'Van', men detta stämmer ej med genetiska data. <!-- Vissa sorter som blommar vid skiljda tidpunkter enlig sammanvägning av uppgifter om blomningstid anges ibland kunna pollinera varandra. -->

**Cirkelns färg:**

- _Mörkgrön_: Blommar under samma period.
- _Ljusgrön_: Blommar under en närliggande period.
- _Blå_: Blommar **ej** under samma eller närliggande, utan ett steg bort från närliggande period.
- _Röd_: Blommar **ej** under samma- eller närliggande period utan ligger i varsin ände av blomningsperioden.
- _Vit_: Uppgifter om relativ blomningstid saknas.

Pollinatörer inom det gröna fältet bör fungera, särskilt om du hittar information från andra källor om att de är lämpliga pollinatörer. För pollinatörer inom det blå fältet och särskilt det röda fältet finns sannolikt en risk att blomningstiderna vissa år inte överlappar tillräckligt för korspollination.

**Cirkelns storlek:**

- _Större_: Fullt kompatibel (alla pollinatörens pollenkorn har förmågan att befrukta mottagaren).
- _Mindre_: Delvis kompatibel (hälften av pollinatörens pollenkorn har förmågan att befrukta mottagaren).
- _Ingen_: Icke-kompatibel (inga av pollinatörens pollenkorn har förmågan att befrukta mottagaren).

Självfertila sorter är markerade med en asterisk (*) efter namnet. De självfertila sorterna är också "universella pollinatörer", dvs de kan befrukta sig själva och alla andra sorter (förutsatt att de blommar samtidigt).

Sorterna är ordnade efter blomningstid från vänster (tidigast) till höger (senast) och nedifrån (tidigast) och upp (senast), undantaget sorter för vilka uppgift om blomningstid saknas (de ligger längst ut i schemat).

Vilket datum de olika blomningstiderna infaller varierar beroende på klimat och väder. I den norska Ullensvang varierar tex starten av blomningen för _Prunus avium_ 'Van' mellan 30 april och 19 maj (vanligen kring 8 maj) beroende på år.

Spelar det någon roll om sorterna är helt- eller delvis kompatibla? Enligt en kanadensisk studie (Andersen 2011) var pollination med helt- respektive delvis kompatibla pollinatörer troligen lika effektivt avseende fruktmängd. För självfertila sorter av sötkörsbär var självpollination lika effektivt som öppen pollination, dock ej för surkörsbär. <!-- andersen-2011-variable-fruit-set-in-self-fertile-sweet-cherry.pdf -->

Tycker du att schemat är svårt att avläsa, prova de sökbara tabellerna nedan istället.

<!-- # Pollinationstabell -->
<!-- Olika flikar med korstabell. -->

<!-- Om det blir för många kan det delas upp såhär: -->

<!-- ## Flik 1 Vanliga sorter -->

<!-- Vanligt förekommande i handeln. -->

<!-- ## Flik 2 Ovanliga sorter -->

<!-- Svåra att få tag på. -->

<!-- ## Flik 3 Alla sorter (tabell istället för figur?) -->

<!-- Alla sorter. -->

## Pollinationsschema med dagar överlapp

Med hjälp av europeiska data från olika orter beräknades hur många dagar de olika sorterna överlappar. Tiden från start av blomning relativt medianvärdet för blomning av alla sorter på en viss plats och år tiden under vilken pollenutbyte kunde ske var tiden från start till full blomning plus fyra dagar (den förväntade tid då blommorna fortfarande är mottagliga). Andelen (%) år då sorterna överlappade tillräckligt beräknades och anges med olika färger (röd = liten andel av åren, grön = hög andel). I varje ruta står en siffra som är medianvärdet för antal dagars överlappning under de undersökta åren. Ett "X" betyder att sorterna är icke-kompatibla, ett "+" efter siffran att de är helt kompatibla, "SC" att sorten är självfertil (alla dessa är delvis kompatibla med sig själva). Övriga är delvis kompatibla. Sorten 'Margit' sticker ut och man kunde se i data att både blomningstidens start (relativt medianvärdet för året) och tiden till full blomning hade större spridning än för övriga sorter.

::: {.column-screen}
![](../../dropbox/images/plants/bt_eur_heatmap.png)
:::




## Pollinationstabell

Varje flik visar sorter som blommar i samma **eller föregående** blomningsgrupp som den i flikens namn. Dvs i fliken "medeltidig" visas även de som är i gruppen "tidig", i fliken "medel" visas även de i gruppen "medeltidig" (igen, men utan de i gruppen "tidig") osv.

Tabellen kan filtreras genom att skriva sökord i rutan under kolumnernas rubriker. Vill du söka efter flera saker samtidigt använd "|" mellan sökorden. Tex ger "van|swe" i kolumnen "Sort" träffar på 'Van' och 'Sweetheart'.

Genetisk kompatibilitet är visat med en stor bokstav. "A" betyder helt kompatibel, "B" betyder delvis kompatibel och "0" betyder **icke-**kompatibel.

Närhet i blomningstid visas med "+" eller "-". Ett "+" betyder att pollinatören ligger en blomningsgrupp bort. Två "++" att de är i samma blomningsgrupp.

::: {.column-screen}

::: {.panel-tabset}

## Medeltidig (och tidig)

```{r} 
#| label: tbl-medeltidig
#| tbl-cap: "Tabell mätvärden"
#| warning: false

sanitize_label <- function(x){
x <- gsub(" \\([^$]*", "", x)
x <- gsub(" \\\n[^$]*", "", x)
x <- gsub(" \\/[^$]*", "", x)
x <- gsub("TM$", "", x)
x <- gsub("Späte Rote Knorpelkirsche", "Rote", x)
x <- gsub("Knauffs Schwarze", "Knauffs", x)
x <- gsub("Große Schwarze Knorpel", "Große Schwarze", x)
x <- gsub("Dönissens Gelbe Knorpel", "Dönissens Gelbe", x)
x <- gsub("Guigne d'Annonay", "Annonay", x)
x <- gsub("Schneiders Späte Knorpelkirsche", "Schneiders Späte", x)

return(x)
}

## read data
varnames3 <- readRDS("../varnames3.rds")
## bt_wide_curated <- read.csv("../bt_wide_curated.csv")
bg12 <- read.csv("../bg12.csv")
bg23 <- read.csv("../bg23.csv")
bg34 <- read.csv("../bg34.csv")
bg45 <- read.csv("../bg45.csv")

query_label <- function(x, y){
    nomatch <- x[!x %in% names(y)]
    names(nomatch) <- nomatch
    y <- c(y, nomatch)
    return(y[match(x, names(y))])
}

library("reactable")

reactable(bg12,
          filterable = TRUE,
          searchable = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = FALSE,
##          searchMethod = JS(), ## See https://glin.github.io/reactable/articles/custom-filtering.html#basic-custom-search-method
          defaultColDef = colDef(
              header = function(value) unname(query_label(value, varnames3)),
              ## cell = function(value) format(value, nsmall = 1),
              align = "center",
              minWidth = 30,
              ## headerStyle = list(background = "#f7f7f8"),
              filterable = TRUE,
      # filtering for multiple values using regex partial match
filterMethod = JS("function(rows, columnId, filterValue) {
        const pattern = new RegExp(filterValue, 'i')
        
        return rows.filter(function(row) {
          return pattern.test(row.values[columnId])
        })
      }")
          ),
          columns = list(
              label = colDef( ## note: use original colname "label"
                  sticky = "left",
                  align = "left",
                  minWidth = 100,
                  ## Add a right border style
                  style = list(borderRight = "1px solid #eee"),
                  headerStyle = list(borderRight = "1px solid #eee")
              )
          )
          )

## ?colFormat()
## Note: "details": Additional content to display when expanding a row. An R
          ## function that takes the row index and column name as
          ## arguments, or a ‘JS()’ function that takes a row info object
          ## and table state object as arguments. Cannot be used on a
          ## ‘groupBy’ column.

## ?colDef()
## ?JS

## Filterfunktioner i reactable: https://github.com/glin/reactable/issues/318
## Guide: https://glin.github.io/reactable/articles/custom-filtering.html

``` 

## Medel (och medeltidig)

```{r } 
#| label: tbl-medel
#| tbl-cap: "Medel"
#| warning: false

reactable(bg23,
          filterable = TRUE,
          searchable = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = FALSE,
          defaultColDef = colDef(
              header = function(value) unname(query_label(value, varnames3)),
              align = "center",
              minWidth = 30,
              filterable = TRUE,
              filterMethod = JS("function(rows, columnId, filterValue) {
        const pattern = new RegExp(filterValue, 'i')
        
        return rows.filter(function(row) {
          return pattern.test(row.values[columnId])
        })
      }")
          ),
          columns = list(
              label = colDef(
                  sticky = "left",
                  align = "left",
                  minWidth = 100,
                  style = list(borderRight = "1px solid #eee"),
                  headerStyle = list(borderRight = "1px solid #eee")
              )
          )
          )


``` 

## Medelsen (och medel)

```{r } 
#| label: tbl-medelsen
#| tbl-cap: "Medelsen"
#| warning: false

reactable(bg34,
          filterable = TRUE,
          searchable = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = FALSE,
          defaultColDef = colDef(
              header = function(value) unname(query_label(value, varnames3)),
              align = "center",
              minWidth = 30,
              filterable = TRUE,
              filterMethod = JS("function(rows, columnId, filterValue) {
        const pattern = new RegExp(filterValue, 'i')
        
        return rows.filter(function(row) {
          return pattern.test(row.values[columnId])
        })
      }")
          ),
          columns = list(
              label = colDef(
                  sticky = "left",
                  align = "left",
                  minWidth = 100,
                  style = list(borderRight = "1px solid #eee"),
                  headerStyle = list(borderRight = "1px solid #eee")
              )
          )
          )


``` 

## Sen (och medelsen)

```{r } 
#| label: tbl-sen
#| tbl-cap: "Sen"
#| warning: false

reactable(bg45,
          filterable = TRUE,
          searchable = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = FALSE,
          defaultColDef = colDef(
              header = function(value) unname(query_label(value, varnames3)),
              align = "center",
              minWidth = 30,
              filterable = TRUE,
              filterMethod = JS("function(rows, columnId, filterValue) {
        const pattern = new RegExp(filterValue, 'i')
        
        return rows.filter(function(row) {
          return pattern.test(row.values[columnId])
        })
      }")
          ),
          columns = list(
              label = colDef(
                  sticky = "left",
                  align = "left",
                  minWidth = 100,
                  style = list(borderRight = "1px solid #eee"),
                  headerStyle = list(borderRight = "1px solid #eee")
              )
          )
          )


``` 

 

:::

:::
